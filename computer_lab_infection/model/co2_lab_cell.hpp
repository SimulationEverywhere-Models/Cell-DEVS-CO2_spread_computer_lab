/**
 * Copyright (c) 2020, Cristina Ruiz Martin
 * ARSLab - Carleton University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/**
* Model developed by Hoda Khalil in Cell-DEVS CD++
* Implemented in Cadmium-cell-DEVS by Cristina Ruiz Martin
*/

#ifndef CADMIUM_CELLDEVS_CO2_CELL_HPP
#define CADMIUM_CELLDEVS_CO2_CELL_HPP

#include <cmath>
#include <nlohmann/json.hpp>
#include <cadmium/celldevs/cell/grid_cell.hpp>

using nlohmann::json;
using namespace cadmium::celldevs;
using namespace std;

/************************************/
/******COMPLEX STATE STRUCTURE*******/
/************************************/
enum CELL_TYPE {AIR=-100, CO2_SOURCE=-200, SUSCEPTIBLE_CO2_SOURCE=-250, IMPERMEABLE_STRUCTURE=-300, DOOR=-400, WINDOW=-500, 	VENTILATION=-600, WORKSTATION=-700};
struct co2 {
    int counter;
    int concentration;
    CELL_TYPE type;
	int breathing_counter=5; //number of cycles since this cell became a CO2 source. Used to know when to add the concentration increase for co2 sources. The default is every five seconds
	int exposure_time=0;
	
    co2() : counter(-1), concentration(500), type(AIR), breathing_counter(0) {}  // a default constructor is required
    co2(int i_counter, int i_concentration, CELL_TYPE i_type, int i_breathing_counter) : counter(i_counter), concentration(i_concentration), type(i_type), breathing_counter(i_breathing_counter){}
};
// Required for comparing states and detect any change
inline bool operator != (const co2 &x, const co2 &y) {
	//note that breathing_counter is not included here intentionally as it is onlu used to add the breathing factor
    return (x.counter != y.counter || x.concentration != y.concentration || x.type != y.type );
}
// Required if you want to use transport delay (priority queue has to sort messages somehow)
inline bool operator < (const co2& lhs, const co2& rhs){ return true; }

// Required for printing the state of the cell
std::ostream &operator << (std::ostream &os, const co2 &x) {
	//note that breathing_counter is not included here as it is not useful for visualization and it will only slow the simulation to include it. Keep it this way unless needed for another reason
    os << "<" << x.counter << "," << x.concentration << "," << x.type << ">";
    return os;
}

// Required for creating co2 objects from JSON file
void from_json(const json& j, co2 &s) {
    j.at("counter").get_to(s.counter);
    j.at("concentration").get_to(s.concentration);
    j.at("type").get_to(s.type);

    //j.at("breathing_counter").get_to(s.breathing_counter);
}

/************************************/
/******COMPLEX CONFIG STRUCTURE******/
/************************************/
struct conc {
    float co2_production; //CO2 generated by one person
    float cell_size;
    int base; //CO2 base level
    int window_conc; //CO2 level at window
    int vent_conc; //CO2 level at vent
    int resp_time;
	int breathing_rate;
	int time_active; //time_active-start_time is the time each occupant spends in the room.
	int start_time; //start state for workstation occupation
	int risky_exposure_time;// if an occupants becomes exposed to risky_concentration for this period of time, they become at risk of infection
	float risky_concentration; //threshhold after which the occupants are at risk
	float flow_weight; //percentage of air coming from airflow_dir
	vector <int> airflow_dir;
 
    // The default is that each cell is 25cm x 25cm x 25cm
    conc(): co2_production(0.026), cell_size(25), base(500), resp_time(5), window_conc(400), vent_conc(400), breathing_rate(5), time_active(100), start_time(30) {}
    conc(float ci, float cs, int b, int wc, int vc, int r, int br, int ta, int st, vector<int> af): co2_production(ci), cell_size(cs), base(b), resp_time(r), window_conc(wc), vent_conc(vc), breathing_rate(br), time_active(ta), start_time(st), airflow_dir(af) {}
};
void from_json(const json& j, conc &c) {
    j.at("co2_production").get_to(c.co2_production);//production per singl human breath 
    j.at("cell_size").get_to(c.cell_size);//It is assumed that the cell size is specified in cm
    j.at("base").get_to(c.base);//base concentration in the building in ppm
    j.at("resp_time").get_to(c.resp_time);
    j.at("window_conc").get_to(c.window_conc);//in ppm
    j.at("vent_conc").get_to(c.vent_conc);//in ppm
    j.at("breathing_rate").get_to(c.breathing_rate);//in seconds
	j.at("time_active").get_to(c.time_active);//the time the occupants spend in the room (time steps that are equivelant to seconds)
	j.at("start_time").get_to(c.start_time);//when the counter Iincremented every clock tick)reaches this value, the worstation is switched to a CO2 source
	
	//infection parameters
	j.at("risky_concentration").get_to(c.risky_concentration);//in ppm. Any level above this cocnentration suggests that the occupants are at risk!
	j.at("flow_weight").get_to(c.flow_weight);
	j.at("risky_exposure_time").get_to(c.risky_exposure_time);
	
	//review this to make it more generic
	int dir_x, dir_y;
	j.at("airflow_dir_x").get_to(dir_x);
	j.at("airflow_dir_y").get_to(dir_y);

	c.airflow_dir.push_back(dir_x);
	c.airflow_dir.push_back(dir_y);
 
}


template <typename T>
class co2_lab_cell : public grid_cell<T, co2> {
public:
    using grid_cell<T, co2, int>::simulation_clock;
    using grid_cell<T, co2, int>::state;
    using grid_cell<T, co2, int>::map;
    using grid_cell<T, co2, int>::neighbors;

    using config_type = conc;  // IMPORTANT FOR THE JSON   
    float concentration_increase; //// CO2 sources have their concentration continually increased
    int base; //CO2 base level 
    int resp_time; //Time used to calculate the concentration inscrease /// set in JSON
    int window_conc; //CO2 level at window
    int vent_conc; //CO2 level at vent
	int breathing_rate; ///the interval between two consecutive breaths in seconds.//set intially from the JSON
	int time_active; ///time spent by the person at the workstation ///set in JSON
	int start_time; ///start time for workstation occupation ///set in JSON
	float risky_concentration; 
	int risky_exposure_time;
	vector<int> airflow_dir;
	float flow_weight;
	
    co2_lab_cell() : grid_cell<T, co2, int>() {
    }

    co2_lab_cell(cell_position const &cell_id, cell_unordered<int> const &neighborhood, co2 initial_state,
        cell_map<co2, int> const &map_in, std::string const &delayer_id, conc config) :
            grid_cell<T, co2>(cell_id, neighborhood, initial_state, map_in, delayer_id) {
				/*The first three multiplied numbers are for unit conversion
				multiplying by 100 to convert from fraction to percentage.
				multiplying by 1000 to convert from liters to cubic meters
				multiplying by 10000 to convert from precentage to ppm (particle per minute)
				*/
                concentration_increase = 100 * 1000 * 10000*config.co2_production/pow(config.cell_size,3);
                base = config.base;
                resp_time = config.resp_time;
                window_conc = config.window_conc;
                vent_conc = config.vent_conc;
				breathing_rate = config.breathing_rate;
				time_active = config.time_active;
				start_time = config.start_time;
				risky_concentration = config.risky_concentration;
				flow_weight = config.flow_weight;
				risky_exposure_time = config.risky_exposure_time;
				airflow_dir = config.airflow_dir;
    }

    co2 local_computation() const override {
    		co2 new_state = state.current_state;
        switch(new_state.type){
            case IMPERMEABLE_STRUCTURE: 
                new_state.concentration = 0;
                break;
            case DOOR:    
                new_state.concentration = base;
                break;
            case WINDOW:
                new_state.concentration = window_conc;
                break;
            case VENTILATION:
                new_state.concentration = vent_conc;
                break;
            case AIR:{
                int concentration = 0;
                int num_neighbors = 0;
				int flow_concentration = 0;
				//calculating diffusion
				//Iterationg on the neighboring cells to
				for(auto neighbors: state.neighbors_state) {
					if( neighbors.second.concentration < 0){
						assert(false && "co2 concentration cannot be negative");
					}
					if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
						if (airflow_dir ==  map.relative(neighbors.first)) {
							flow_concentration = neighbors.second.concentration*flow_weight;				
						}
						else{
							concentration += neighbors.second.concentration;
						}
						num_neighbors +=1;
					}
				}
				if( flow_concentration != 0 )
					new_state.concentration = (1-flow_weight)*concentration/(num_neighbors-1) + flow_concentration;
				else
					new_state.concentration = concentration/num_neighbors;
				break;             
            }
            case WORKSTATION:{
                int concentration = 0;
                int num_neighbors = 0;                
				//calculating diffusion
				//Iterationg on the neighboring cells to caclulate the average CO2 level
				for(auto neighbors: state.neighbors_state) {
					if( neighbors.second.concentration < 0){
						assert(false && "co2 concentration cannot be negative");
					}
					if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
						concentration += neighbors.second.concentration;
						num_neighbors +=1;
					}
				}
				new_state.concentration = concentration/num_neighbors;
                //The purpose of the counter is to have different start times for each cell. Initially, each occupant has a different counter and it determines when this occupant will be active as a CO2 source in the workstation
				if (state.current_state.counter <= start_time) { 
                    new_state.counter += 1;                   
                }
				//The workstation switches to occupied when the counter of each occupant exceeds the start time
                if (state.current_state.counter == start_time){
                    new_state.type = CO2_SOURCE; 
					new_state.breathing_counter = 0;
				}
                break;
            }
            case CO2_SOURCE:{
                int concentration = 0;
                int num_neighbors = 0;
				//calculating diffusion
				//Iterationg on the neighboring cells to caclulate the average CO2 level
				for(auto neighbors: state.neighbors_state) {
				  if( neighbors.second.concentration < 0){
						assert(false && "co2 concentration cannot be negative");
					}
					  if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
						concentration += neighbors.second.concentration;
						num_neighbors +=1;
					}               
				}
				new_state.concentration = (concentration/num_neighbors);
				//The concentration increases every time an occupant breathes (the default breathing rate is every five seconds)
				if( (new_state.breathing_counter % breathing_rate ) == 0)
					new_state.concentration += concentration_increase;
				//The breathing counter is there to know how many clock ticks have passed since the last breath. The purpose for this is to add CO2 (concentration_increase) that represents the CO2 production from each breath only when the time interval of breathing_rate passes. Example: if the breathing rate is every 5 econds, the concentration increase will be added at 0,5,10,15, etc.
				new_state.breathing_counter++;
				//The occupant switches to workstation when the counter of each occupant exceeds the time active. time_active-start_time is the time each occupant spends in the room.
                new_state.counter += 1;
				if (state.current_state.counter == time_active ) {
                    new_state.type = WORKSTATION; //The student left. The place is free.
                }
				else
                if (new_state.concentration >= risky_concentration){
					new_state.exposure_time++;
					if (new_state.exposure_time >= risky_exposure_time) new_state.type = SUSCEPTIBLE_CO2_SOURCE;
				} 
					
                break;
            }
			case SUSCEPTIBLE_CO2_SOURCE:{
                int concentration = 0;
                int num_neighbors = 0;
				//calculating diffusion
				//Iterationg on the neighboring cells to caclulate the average CO2 level
				for(auto neighbors: state.neighbors_state) {
				  if( neighbors.second.concentration < 0){
						assert(false && "co2 concentration cannot be negative");
					}
					  if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
						concentration += neighbors.second.concentration;
						num_neighbors +=1;
					}               
				}
				new_state.concentration = (concentration/num_neighbors);
				//The concentration increases every time an occupant breathes (the default breathing rate is every five seconds)
				if( (new_state.breathing_counter % breathing_rate ) == 0)
					new_state.concentration += concentration_increase;
				//The breathing counter is there to know how many clock ticks have passed since the last breath. The purpose for this is to add CO2 (concentration_increase) that represents the CO2 production from each breath only when the time interval of breathing_rate passes. Example: if the breathing rate is every 5 econds, the concentration increase will be added at 0,5,10,15, etc.
				new_state.breathing_counter++;
				//The occupant switches to workstation when the counter of each occupant exceeds the time active. time_active-start_time is the time each occupant spends in the room.
                new_state.counter += 1;
                if (state.current_state.counter == time_active ) {
                    new_state.type = WORKSTATION; //The student left. The place is free.
                }else
                if (new_state.concentration < risky_concentration){
					new_state.exposure_time = 0;
					new_state.type = CO2_SOURCE;
				}
				
                break;
            }
            default:{
                assert(false && "should never happen");
            }
        }
      
        return new_state;

    }

    // It returns the delay to communicate cell's new state.
    T output_delay(co2 const &cell_state) const override {
		return resp_time;
    }

};

#endif //CADMIUM_CELLDEVS_CO2_CELL_HPP













